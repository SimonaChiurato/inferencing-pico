#include <stdio.h>
#include "pico/stdlib.h"
#include "ei_run_classifier.h"

const uint LED_PIN = 25;

static const float samples[][EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE] = {
{1.50877833993219, 1.45586084344769, 1.44240231266943, 1.58803964802812, 1.63022691911195, 1.45506737530041, 1.49500038287113, 1.60328051304554, 1.59483791598143, 1.56869331584992, 1.51735433637836, 1.57590348465007, 1.58823440701935, 1.61794541325462, 1.57017588311176, 3.16846534604615, 2.9658794709638, 3.14368193251612, 3.14028427860927, 3.12824557899204, 3.15316819676542, 3.13649504701481, 3.08475524426611, 3.2312850671217, 3.20740647867835, 3.13953630111367, 3.1138902285003, 3.18042959834673, 3.26010660564456, 3.15912732496787},
{-0.011150038992051, 0.0743703884043917, 0.00762416499612988, -0.0852905925788302, -0.0209067022139773, 0.00560580837648394, -0.0291843767113577, 0.00682723663712169, -0.0279424711546575, -0.0218222877203998, -0.110180108147647, 0.0011131782751517, 0.012768964629641, -0.0308437533502909, -0.0388608300745076, 0.00291976950600293, 0.125309492789012, 0.023097027249407, 0.0442129727531089, -0.0318977992029815, 0.00776362775418457, 0.0317753166968739, -0.0386439999314388, 0.0984684290782456, -0.0411330604828756, -0.061808101528522, 0.116971421322019, -0.0381937548305766, 0.0302671910668739, 0.0280897671160451},
{-0.00111260903237694, 0.00908536645429837, -0.0143064691317035, -0.00536449709837547, -0.00454409701090348, -0.0103491973164404, -0.0134777816536193, -0.00383368526658756, -0.00861533370521822, 0.00579205461403863, -0.000923273610784305, 0.00964787449487608, 0.000927544097171237, 0.0029656098245991, 0.0113400621052923, 0.0777133314928986, -0.0302420862634208, 0.0376809566457283, -0.099086676865397, 0.0169379662043612, 0.0779391395921959, -0.0442970062263382, 0.105360975146241, 0.0059603974022036, 0.0565601502937303, 0.110188802897179, -0.110875521893773, 0.0484372266831763, -0.0678660970483867, -0.0107068913966743},
{3.30931400221932, 3.33246766036366, 3.32246059174667, 3.33010499869117, 3.3423842769586, 3.4258260076144, 3.34369621999937, 3.36804455420355, 3.38172110493874, 3.33924389021154, 3.42590586166752, 3.38524673273274, 3.28498578136352, 3.4040353536968, 3.4368499495006, 6.61141868630567, 6.62746763802741, 6.68552752605171, 6.67906990711527, 6.85213972873303, 6.69242559220042, 6.72683707687161, 6.79999036373424, 6.6182369890067, 6.95814804622981, 6.80361707503527, 6.68145907322116, 6.80733181413231, 6.79787954301494, 6.70668220144623},
{0.844259820468534, 0.904712565809047, 0.908047703173079, 0.908655214212797, 0.835434363738987, 0.886299441181391, 0.924558136388896, 0.869884504345953, 0.862707259327706, 0.894519822962156, 0.851196352916055, 0.926340346121023, 0.812560684177935, 0.78881357954137, 0.806652510903963, 1.9104861612264, 1.79741048926819, 1.66519336048807, 1.95103384031933, 1.65988544462832, 1.76499281497085, 1.748615743575, 1.73549626857386, 1.66740098918643, 1.77781650190109, 1.70954374636246, 1.73202556739306, 1.60898103724515, 1.68587572089213, 1.80629514411937},
{1.22108033685853, 1.21287890768495, 1.2404442672604, 1.22991359887965, 1.16425786429154, 1.197969228143, 1.18873399880348, 1.22035692170779, 1.21817022034591, 1.19434540433348, 1.19597994100854, 1.13217840265479, 1.1901951957361, 1.1892191048685, 1.22230455771172, 3.00007153329259, 3.13403993130606, 3.05719105338111, 3.01731325645801, 2.888068623504, 3.05938860220854, 3.04581106854272, 2.99320993651901, 2.9135092286077, 2.88536826479945, 3.02185650929757, 2.99664622708112, 3.00235854999029, 2.97985744012918, 3.02964472880626},
{2.25382017419772, 2.20783653614561, 2.28575398140141, 2.29036026970202, 2.3321314677261, 2.29670515016047, 2.30625842796438, 2.26456944195039, 2.27234652201839, 2.2726418847339, 2.23114065230054, 2.24855714993214, 2.25834114689245, 2.23441320752694, 2.25403475255519, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0},
{0.50916980530668, 0.711054956662089, 0.844390670913799, 0.541175914431714, 0.425569959036242, 0.630381940318559, 0.662105189877312, 0.811877296947583, 0.535072390007568, 0.234927229337483, 0.911023696998887, 0.639561848467687, 0.724039460640809, 0.638540081739977, 0.697512481000131, 1.02435836617051, 1.09348423304977, 1.07017823484117, 0.97096620788323, 1.10271907134557, 1.02535253546173, 1.00309287667079, 0.970127039468646, 1.00606322749072, 0.958318258700472, 1.04413692984015, 0.932401497911664, 1.02847271238519, 0.957355820414925, 1.02039936498183},
{0.719745797385914, 0.690552003627642, 0.720459571493496, 0.655359196051521, 0.601067349248994, 0.61470159837897, 0.613218012119032, 0.565649194293912, 0.679745529926612, 0.644804333422155, 0.666552783479799, 0.657598827670987, 0.529783060727232, 0.673649481455181, 0.572775552798519, 1.42218242469185, 1.43153421942346, 1.43380424880256, 1.29246881735809, 1.17081266696361, 1.47289031266913, 1.28492964854475, 1.20899871769222, 1.24890355152065, 1.30235275509887, 1.26346148206297, 1.31424850166453, 1.27480866814621, 1.31746787684439, 1.24268546531918},
{1.09437606410252, 1.07058673165671, 1.00918495145597, 0.978840566985848, 0.961752419641459, 0.945212982401317, 0.861269855055572, 0.954777674092275, 0.872012119646036, 0.82466550312748, 0.820612339485064, 0.825662221274371, 0.848257612087407, 0.77019343550779, 0.826814450987825, 2.5744943965627, 2.55957765447195, 2.52945716560689, 2.4821158186656, 2.23740345005787, 2.37302224113147, 2.29457387812453, 2.30710985436883, 2.2790551780703, 2.16519839750841, 1.98364068304636, 2.13487706296898, 2.14172058509461, 2.08190343687185, 1.96897001057219},
};

static const float true_results[] = {1, 1, 0, 1, 1, 0, 0, 0, 1, 0};
int raw_feature_get_data(size_t sampleIndex, size_t offset, size_t length, float *out_ptr) {
    if (sampleIndex >= sizeof(samples) / sizeof(samples[0])) {
        return -1; // Error: Invalid sample index
    }
    memcpy(out_ptr, samples[sampleIndex] + offset, length * sizeof(float));
    return 0;
}

int main() {
    stdio_init_all();
    gpio_init(LED_PIN);
    gpio_set_dir(LED_PIN, GPIO_OUT);
    
    gpio_put(LED_PIN, 1);
    sleep_ms(250);
    gpio_put(LED_PIN, 0);
    sleep_ms(250);
while(true) {
    int correct_predictions = 0; 
    for (size_t sampleIdx = 0; sampleIdx < sizeof(samples) / sizeof(samples[0]); sampleIdx++) {
        
        if (sizeof(samples[sampleIdx]) / sizeof(float) != EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE) {
            ei_printf("The size of your 'features' array is not correct. Expected %lu items, but had %lu\n",
                EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE, sizeof(samples[sampleIdx]) / sizeof(float));
            sleep_ms(1000);
            return -1;
        }

        ei_impulse_result_t result = {0};
        
        signal_t features_signal;
        features_signal.total_length = sizeof(samples[sampleIdx]) / sizeof(samples[0][0]);
        features_signal.get_data = [sampleIdx](size_t offset, size_t length, float *out_ptr) -> int {
            return raw_feature_get_data(sampleIdx, offset, length, out_ptr);
        };

        
        ei_printf("Edge Impulse standalone inferencing (Raspberry Pico 2040)\n");
        ei_printf("Processing sample index: %zu\n", sampleIdx);
        gpio_put(LED_PIN, 0);
        EI_IMPULSE_ERROR res = run_classifier(&features_signal, &result, false /* debug */);
        ei_printf("run_classifier returned: %d\n", res);

        if (res != 0) return res;

        ei_printf("Predictions ");
        ei_printf("(DSP: %d ms., Classification latency: %d ms., Anomaly: %d ms.)",
            result.timing.dsp, result.timing.classification, result.timing.anomaly);
        ei_printf(": \n");
        ei_printf("[");
        for (size_t ix = 0; ix < EI_CLASSIFIER_LABEL_COUNT; ix++) {
            ei_printf("%.5f", result.classification[ix].value);
            if (ix != EI_CLASSIFIER_LABEL_COUNT - 1) {
                ei_printf(", ");
            }
        }
        ei_printf("]\n");

        for (size_t ix = 0; ix < EI_CLASSIFIER_LABEL_COUNT; ix++) {
            ei_printf("    %s: %.5f\n", result.classification[ix].label, result.classification[ix].value);
            if (result.classification[ix].value > 0.5 && true_results[sampleIdx] == ix) { 
                correct_predictions++; 
            }
        }
        
        ei_printf(" (True result: %.1f)", true_results[sampleIdx]);
        float accuracy = (float)correct_predictions / (sizeof(true_results) / sizeof(true_results[0])) * 100.0f;
        ei_printf("Accuracy: %.2f%%\n", accuracy);
#if EI_CLASSIFIER_HAS_ANOMALY == 1
        ei_printf("    anomaly score: %.3f\n", result.anomaly);
#endif
        gpio_put(LED_PIN, 1);
        sleep_ms(1000);
    }
    float accuracy = (float)correct_predictions / (sizeof(true_results) / sizeof(true_results[0])) * 100.0f;
    ei_printf("Accuracy: %.2f%%\n", accuracy);
}

    return 0;
}
